"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportDotx = void 0;
const JSZip = require("jszip");
const xml_js_1 = require("xml-js");
const footer_wrapper_1 = require("file/footer-wrapper");
const header_wrapper_1 = require("file/header-wrapper");
const media_1 = require("file/media");
const relationship_1 = require("file/relationships/relationship/relationship");
const xml_components_1 = require("file/xml-components");
const schemeToType = {
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header": "header",
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer": "footer",
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image": "image",
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink": "hyperlink",
};
var RelationshipType;
(function (RelationshipType) {
    RelationshipType["HEADER"] = "header";
    RelationshipType["FOOTER"] = "footer";
    RelationshipType["IMAGE"] = "image";
    RelationshipType["HYPERLINK"] = "hyperlink";
})(RelationshipType || (RelationshipType = {}));
class ImportDotx {
    extract(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const zipContent = yield JSZip.loadAsync(data);
            const documentContent = yield zipContent.files["word/document.xml"].async("text");
            const relationshipContent = yield zipContent.files["word/_rels/document.xml.rels"].async("text");
            const documentRefs = this.extractDocumentRefs(documentContent);
            const documentRelationships = this.findReferenceFiles(relationshipContent);
            const media = new media_1.Media();
            const templateDocument = {
                headers: yield this.createHeaders(zipContent, documentRefs, documentRelationships, media, 0),
                footers: yield this.createFooters(zipContent, documentRefs, documentRelationships, media, documentRefs.headers.length),
                currentRelationshipId: documentRefs.footers.length + documentRefs.headers.length,
                styles: yield zipContent.files["word/styles.xml"].async("text"),
                titlePageIsDefined: this.checkIfTitlePageIsDefined(documentContent),
                media: media,
            };
            return templateDocument;
        });
    }
    createFooters(zipContent, documentRefs, documentRelationships, media, startingRelationshipId) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = documentRefs.footers
                .map((reference, i) => __awaiter(this, void 0, void 0, function* () {
                const relationshipFileInfo = documentRelationships.find((rel) => rel.id === reference.id);
                if (relationshipFileInfo === null || !relationshipFileInfo) {
                    throw new Error(`Can not find target file for id ${reference.id}`);
                }
                const xmlData = yield zipContent.files[`word/${relationshipFileInfo.target}`].async("text");
                const xmlObj = xml_js_1.xml2js(xmlData, { compact: false, captureSpacesBetweenElements: true });
                if (!xmlObj.elements) {
                    return undefined;
                }
                const xmlElement = xmlObj.elements.reduce((acc, current) => (current.name === "w:ftr" ? current : acc));
                const importedComp = xml_components_1.convertToXmlComponent(xmlElement);
                const wrapper = new footer_wrapper_1.FooterWrapper(media, startingRelationshipId + i, importedComp);
                yield this.addRelationshipToWrapper(relationshipFileInfo, zipContent, wrapper, media);
                return { type: reference.type, footer: wrapper };
            }))
                .filter((x) => !!x);
            return Promise.all(result);
        });
    }
    createHeaders(zipContent, documentRefs, documentRelationships, media, startingRelationshipId) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = documentRefs.headers
                .map((reference, i) => __awaiter(this, void 0, void 0, function* () {
                const relationshipFileInfo = documentRelationships.find((rel) => rel.id === reference.id);
                if (relationshipFileInfo === null || !relationshipFileInfo) {
                    throw new Error(`Can not find target file for id ${reference.id}`);
                }
                const xmlData = yield zipContent.files[`word/${relationshipFileInfo.target}`].async("text");
                const xmlObj = xml_js_1.xml2js(xmlData, { compact: false, captureSpacesBetweenElements: true });
                if (!xmlObj.elements) {
                    return undefined;
                }
                const xmlElement = xmlObj.elements.reduce((acc, current) => (current.name === "w:hdr" ? current : acc));
                const importedComp = xml_components_1.convertToXmlComponent(xmlElement);
                const wrapper = new header_wrapper_1.HeaderWrapper(media, startingRelationshipId + i, importedComp);
                yield this.addRelationshipToWrapper(relationshipFileInfo, zipContent, wrapper, media);
                return { type: reference.type, header: wrapper };
            }))
                .filter((x) => !!x);
            return Promise.all(result);
        });
    }
    addRelationshipToWrapper(relationhipFile, zipContent, wrapper, media) {
        return __awaiter(this, void 0, void 0, function* () {
            const refFile = zipContent.files[`word/_rels/${relationhipFile.target}.rels`];
            if (!refFile) {
                return;
            }
            const xmlRef = yield refFile.async("text");
            const wrapperImagesReferences = this.findReferenceFiles(xmlRef).filter((r) => r.type === RelationshipType.IMAGE);
            const hyperLinkReferences = this.findReferenceFiles(xmlRef).filter((r) => r.type === RelationshipType.HYPERLINK);
            for (const r of wrapperImagesReferences) {
                const buffer = yield zipContent.files[`word/${r.target}`].async("nodebuffer");
                const mediaData = media.addMedia(buffer);
                wrapper.Relationships.createRelationship(r.id, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", `media/${mediaData.fileName}`);
            }
            for (const r of hyperLinkReferences) {
                wrapper.Relationships.createRelationship(r.id, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink", r.target, relationship_1.TargetModeType.EXTERNAL);
            }
        });
    }
    findReferenceFiles(xmlData) {
        const xmlObj = xml_js_1.xml2js(xmlData, { compact: true });
        const relationXmlArray = Array.isArray(xmlObj.Relationships.Relationship)
            ? xmlObj.Relationships.Relationship
            : [xmlObj.Relationships.Relationship];
        const relationships = relationXmlArray
            .map((item) => {
            if (item._attributes === undefined) {
                throw Error("relationship element has no attributes");
            }
            return {
                id: this.parseRefId(item._attributes.Id),
                type: schemeToType[item._attributes.Type],
                target: item._attributes.Target,
            };
        })
            .filter((item) => item.type !== null);
        return relationships;
    }
    extractDocumentRefs(xmlData) {
        const xmlObj = xml_js_1.xml2js(xmlData, { compact: true });
        const sectionProp = xmlObj["w:document"]["w:body"]["w:sectPr"];
        const headerProps = sectionProp["w:headerReference"];
        let headersXmlArray;
        if (headerProps === undefined) {
            headersXmlArray = [];
        }
        else if (Array.isArray(headerProps)) {
            headersXmlArray = headerProps;
        }
        else {
            headersXmlArray = [headerProps];
        }
        const headers = headersXmlArray.map((item) => {
            if (item._attributes === undefined) {
                throw Error("header referecne element has no attributes");
            }
            return {
                type: item._attributes["w:type"],
                id: this.parseRefId(item._attributes["r:id"]),
            };
        });
        const footerProps = sectionProp["w:footerReference"];
        let footersXmlArray;
        if (footerProps === undefined) {
            footersXmlArray = [];
        }
        else if (Array.isArray(footerProps)) {
            footersXmlArray = footerProps;
        }
        else {
            footersXmlArray = [footerProps];
        }
        const footers = footersXmlArray.map((item) => {
            if (item._attributes === undefined) {
                throw Error("footer referecne element has no attributes");
            }
            return {
                type: item._attributes["w:type"],
                id: this.parseRefId(item._attributes["r:id"]),
            };
        });
        return { headers, footers };
    }
    checkIfTitlePageIsDefined(xmlData) {
        const xmlObj = xml_js_1.xml2js(xmlData, { compact: true });
        const sectionProp = xmlObj["w:document"]["w:body"]["w:sectPr"];
        return sectionProp["w:titlePg"] !== undefined;
    }
    parseRefId(str) {
        const match = /^rId(\d+)$/.exec(str);
        if (match === null) {
            throw new Error("Invalid ref id");
        }
        return parseInt(match[1], 10);
    }
}
exports.ImportDotx = ImportDotx;
//# sourceMappingURL=import-dotx.js.map